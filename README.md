# VPN Solution with Python Sockets

## Abstract

The project revolves around the development of a Python-based VPN solution that prioritizes secure communication between clients and a central server. The primary objectives include the establishment of secure tunnels using TUN interfaces, encryption and decryption of data packets through advanced cryptographic techniques, and the implementation of a robust authentication system using Kerberos. 

## 1. Introduction

### 1.1 VPN Technology

Virtual Private Networks (VPNs) are a crucial technology in today's digital landscape, primarily used for securing internet connections and maintaining privacy. They create a protected network connection, effectively establishing a private network over a public internet infrastructure. This is achieved by encrypting data before it is sent over the internet, ensuring that sensitive information remains confidential and secure from unauthorized access. VPNs are widely utilized for various purposes, ranging from accessing region-restricted content to safeguarding sensitive data transfers for businesses and individuals alike. Their ability to provide secure and private communication over the internet has made them an indispensable tool in both personal and professional contexts.

### 1.2 Kerberos

[Imgur](https://i.imgur.com/ql5Oa45.png)

The image depicts the Kerberos authentication process, a network authentication protocol designed to provide strong authentication for client/server applications using secret-key cryptography.

1. The client sends an authentication request (KRB_AS_REQ) to the Key Distribution Center (KDC).
2. The KDC replies with a response (KRB_AS_REP), providing a ticket-granting ticket (TGT).
3. The client then requests a service ticket (KRB_TGS_REQ) using the TGT.
4. The KDC responds with the service ticket (KRB_TGS_REP).
5. The client sends the service ticket to the server in an application request (KRB_AP_REQ).
6. The server responds (KRB_AP_REP), granting access if the ticket is valid.

## 2. Theoretical Framework

### 2.1 Overview of Tun/Tap Architecture (Client)

![Imgur](https://i.imgur.com/0YrUxrr.jpg)

The TUN/TAP architecture allows for the creation of virtual network interfaces that operate at different layers of the OSI model. The client.py script plays a pivotal role in preparing the packets for secure VPN transit, ensuring they are encrypted and encapsulated before they are sent through the user's actual network interfaces to the VPN server.

- A packet generated by the user's device enters the TUN interface. The TUN interface operates at the network layer (layer 3) and deals with IP packets.
- The client.py script is responsible for several critical operations, including sniffing the tun interface for outgoing packets, encrypting the packet for secure transmission, handling the encapsulation process as per VPN requirements, and sending the encapsulated packet to the eth interface.
- The eth or wlan interface is where the encapsulated packet is sent out to the network.

### 2.2 Server Functioning

![Imgur](https://i.imgur.com/fX1IMlc.jpg)

**Socket Connections:**
Each client establishes a socket connection with the VPN server, maintaining a separate socket connection for simultaneous data exchange.

**Encryption and Decryption:**
The server handles encryption and decryption for data packets sent to and from the clients. Each client has its own encryption key, ensuring secure communication.

**IP Mapping:**
The server.py script maps the destination IP address of each packet to the corresponding client socket, consulting a database with IP-to-socket mappings.

**Database Integration:**
The VPN server uses a database to store and manage IP-to-socket mappings, encryption keys, and virtual network information.

### 2.3 Messaging Formats

#### 2.3.1 Connection (Socket) Creation

![Imgur](https://i.imgur.com/1gcnyi4.png)

**Kerberos Initialization (kinit):**
The client initiates the process by sending a kinit request along with its identifier (id) and the Key Distribution Center (KDC) hostname within the realm (domain) to the KDC.

**TGT Response:**
The KDC validates the client's credentials and sends back the TGT, encrypted with a key derived from the client’s password.

**Service Ticket Request:**
The client requests a service ticket to the KDC, including the TGT and specifying the desired service.

**TGS Response:**
The KDC responds with a service ticket (TGS), encrypted with the service’s secret key.

**Authentication to Server:**
The client sends an authentication message to the server, including the TGS, client's ID, network address, and an authenticator.

**Server Verification (Verif):**
Upon receiving the message, the server decrypts the TGS and authenticator, verifying the client's identity.

**Server Response:**
The server sends a response back to the client, confirming the mutual authentication process.

#### 2.3.2 Packet Exchange Messages

![Imgur](https://i.imgur.com/FaWtHN8.png)

**Authentication and Socket Connection Establishment:**
The client sends an initial authentication message to the server, containing the client's identifier (Id) and an encrypted Ticket Granting Service (TGSenc).

**Data Transmission Over the Socket:**
After the socket connection is established, the client sends data over this connection in a message constructed as { Id, pkt64, TGSenc }.HMAC( [ ] + key ).

**Server Response with Verification:**
For incoming packets, the server sends a verification token in the form of pktenc.HMAC(pkt + key), confirming successful verification.

## 3. Implementation Details

### 3.1 Client Functions

#### 3.1.1 secureEncode(machine_id, packet, TGS, enc_key)

This function takes the machine ID, packet data, Ticket-Granting Server (TGS) response, and encryption key as input. It encodes the information into a JSON format, encrypts it using AES-256 encryption with the provided key, and returns the resulting data along with an HMAC for integrity verification.

#### 3.1.2 secureDecode(data)

The secureDecode function takes encoded data as input, splits it into the encrypted JSON and HMAC components, decrypts the JSON using AES-256 encryption, and verifies its integrity using the provided HMAC. If the integrity is confirmed, it returns the decoded packet; otherwise, it indicates that no integrity verification is achieved for the packet.

#### 3.1.3 parse_json_file()

This function reads a JSON configuration file ('ppp.json') containing parameters such as local and server IP addresses, port, encryption key, Kerberos key, and machine ID. It then sets global variables with these values for later use.

#### 3.1.4 create_tun()

The create_tun function initializes a TUN/TAP device named 'tun0' with specific configuration parameters like IP address, netmask, and MTU. It prepares the TUN/TAP device for communication.

#### 3.1.5 getTGS()

This function obtains a Ticket-Granting Server (TGS) response by initializing a Kerberos client context, authenticating the user's credentials, and obtaining the TGS response for the specified service. It returns the TGS response for later use in the VPN communication.

#### 3.1.6 socketInit(TGS)

The socketInit function initializes a TCP socket and connects it to the server specified in the configuration file. It then encrypts the TGS response using AES-256 encryption and sends a formatted JSON message containing the machine ID and encrypted TGS to the server.

#### 3.1.7 sniffer()

The sniffer function continuously monitors the TUN/TAP device for incoming packets. When a packet is received, it checks if the source IP matches the local IP, and if so, it encodes the packet using secureEncode and sends it to the server through the initialized socket.

#### 3.1.8 listener()

The listener function continuously listens for incoming data from the server through the socket. It decodes the received JSON message, performs secureDecode on the packet, and writes the decrypted packet to the TUN/TAP device if the destination IP matches the local IP.

#### 3.1.9 main()

In the main block, the script initializes the VPN client by parsing the JSON file, creating the TUN/TAP device, obtaining the TGS, and initializing the socket. Two threads, one for listening and the other for sniffing, are started to handle incoming and outgoing traffic concurrently.

### 3.2 Server Functions

#### 3.2.1 handle_client(client_socket, name, client_sockets)

This function handles the communication with a connected client in a separate thread. It continuously receives data from the client, decodes the JSON message using secureDecode, extracts source and destination IPs from the packet, and forwards the data to the appropriate destination client using the dictionary of client sockets. If the data received is empty, it removes the client from the dictionary and closes the connection.

#### 3.2.2 main()

The main block initializes a TCP/IP server socket and binds it to a specific IP address and port. It listens for incoming connections and, upon accepting a connection, receives the name of the client as the first message. It then creates a new thread (client_thread) to handle the communication with the client using the handle_client function. The server maintains a dictionary (client_sockets) that maps client names to their respective sockets. Each new connection is confirmed with a message printed to the console. The server runs indefinitely, accepting and handling client connections concurrently.

## 5. Usage

**Client Side:**

**client.json:**

![Imgur](https://i.imgur.com/VuxsXZA.png)

**Usage:**

```bash
python client.py
```

**Server Side:**

**Usage:**

```bash
python server.py
```
